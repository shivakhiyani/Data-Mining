# -*- coding: utf-8 -*-
"""sampling4a,b,5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P963OJ_hZxDzGfVjdwvUxZBirkALjt_r
"""

import matplotlib.pyplot as plt
import random
import math
from scipy import stats
import numpy as np

def uniform_icdf(min,max,y):
  return min +(max-min)*y

def get_samples(min,max, n_samples):
  samples = []
  for i in range(n_samples):
    y = np.random.uniform(0,1)
    x = uniform_icdf(min,max,y)
    samples.append(x)
  return samples

samples = get_samples(2,5,2000)
count, bins, ignored = plt.hist(samples, 15, density = True)
plt.plot(bins,np.ones_like(bins))
plt.ylim(0,0.4)
plt.show()

def rejection_sampling(mu, sigma):
  pdf = stats.norm(mu,sigma)
  d_max = pdf.pdf(mu)
  while True:
    x = np.random.uniform(mu-3*sigma,mu+3*sigma,1)[0]
    y = np.random.uniform(0,d_max,1)
    if y<=pdf.pdf(x):
      break
  return x,y

def get_samples(mu, sigma, n_samples):
  samples = []
  for i in range(n_samples):
    sample = rejection_sampling(mu,sigma)
    samples.append(sample[0])
  return samples
samples = get_samples(3,1,1000)
# print(samples)
count, bins, ignored = plt.hist(samples, 100, density=True)
plt.plot(bins, stats.norm(3,1).pdf(bins), linewidth=2)



def two_d_sampling(sample,m,sigma):
  array_x = []
  array_y = []
  while len(array_x)<sample:
    x_min = m[0]-(5*m[0])
    x_max=m[0] + (5*m[0])
    y_min = m[1]-(5*m[1])
    y_max=m[1] + (5*m[1])
    new_x = random.uniform(x_min,x_max)
    new_y = random.uniform(y_min,y_max)
    new_z = stats.multivariate_normal.pdf([new_x,new_y],m,sigma)
    random_y = random.random()
    if random_y < new_z:
      array_x.append(new_x)
      array_y.append(new_y)
  return array_x, array_y

array_x, array_y = two_d_sampling(3000, [1,1], [[1,0],[0,1]])
plt.plot(array_x,array_y,'*')
plt.show

rho=0.5
def y_x(x,m1,m2,sigma1,sigma2):
  m= m2+rho*sigma2/sigma1*(x-m1)
  s= math.sqrt(1-pow(rho,2))*sigma2
  l1,l2 = rejection_sampling(m,s)
  
  return l1
def x_y(y,m1,m2,sigma1,sigma2):
  m= m1+rho*sigma1/sigma2*(y-m2)
  s= math.sqrt(1-pow(rho,2))*sigma1
  l1,l2 = rejection_sampling(m,s)
  
  return l1

def gibbs_sampling(mu,sigma,N):
  K=20
  xres =[]
  yres = []
  m1 = mu[0]
  m2 = mu[1]
  sigma1 = sigma[0]
  sigma2 = sigma[1]
  y=m2
  for i in range(N):
    for j in range(K):
      x = x_y(y,m1,m2,sigma1, sigma2)
      y = y_x(x,m1,m2,sigma1, sigma2)
      xres.append(x)
      yres.append(y)
  for i in range(len(xres)):
    plt.plot(xres[i],yres[i],'r+')
  plt.show()

mu = [10,-5]
sigma = [5,2]
gibbs_sampling(mu,sigma,100)